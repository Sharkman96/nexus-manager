const { exec, spawn } = require('child_process');
const { promisify } = require('util');
const config = require('../../config');

const execAsync = promisify(exec);

class NexusCLI {
  constructor() {
    this.cliPath = config.nexus.cliPath;
    this.runningNodes = new Map(); // –ö–∞—Ä—Ç–∞ –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ Nexus CLI
   */
  async checkCLIAvailability() {
    try {
      const { stdout } = await execAsync(`${this.cliPath} --version`);
      return {
        available: true,
        version: stdout.trim()
      };
    } catch (error) {
      return {
        available: false,
        error: error.message
      };
    }
  }

  /**
   * –ó–∞–ø—É—Å–∫ —É–∑–ª–∞
   */
  async startNode(proverId, options = {}) {
    try {
      const command = this.buildStartCommand(proverId, options);
      console.log(`üöÄ Starting node with command: ${command}`);

      const nodeProcess = spawn(this.cliPath, command.split(' ').slice(1), {
        stdio: ['pipe', 'pipe', 'pipe'],
        detached: false
      });

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ—Ü–µ—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
      this.runningNodes.set(proverId, nodeProcess);

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–≤–æ–¥–∞
      nodeProcess.stdout.on('data', (data) => {
        console.log(`[${proverId}] ${data.toString()}`);
      });

      nodeProcess.stderr.on('data', (data) => {
        console.error(`[${proverId}] ERROR: ${data.toString()}`);
      });

      nodeProcess.on('exit', (code) => {
        console.log(`[${proverId}] Process exited with code ${code}`);
        this.runningNodes.delete(proverId);
      });

      return {
        success: true,
        pid: nodeProcess.pid,
        message: 'Node started successfully'
      };

    } catch (error) {
      console.error(`‚ùå Failed to start node ${proverId}:`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —É–∑–ª–∞
   */
  async stopNode(proverId) {
    try {
      const nodeProcess = this.runningNodes.get(proverId);
      
      if (nodeProcess) {
        nodeProcess.kill('SIGTERM');
        
        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞
        await new Promise((resolve) => {
          nodeProcess.on('exit', resolve);
          setTimeout(() => {
            if (!nodeProcess.killed) {
              nodeProcess.kill('SIGKILL');
            }
            resolve();
          }, 5000);
        });

        this.runningNodes.delete(proverId);
        
        return {
          success: true,
          message: 'Node stopped successfully'
        };
      } else {
        // –ü–æ–ø—ã—Ç–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —á–µ—Ä–µ–∑ CLI
        const { stdout } = await execAsync(`${this.cliPath} node stop --prover-id ${proverId}`);
        return {
          success: true,
          message: 'Node stopped via CLI',
          output: stdout
        };
      }
    } catch (error) {
      console.error(`‚ùå Failed to stop node ${proverId}:`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —É–∑–ª–∞
   */
  async getNodeStatus(proverId) {
    try {
      const { stdout } = await execAsync(`${this.cliPath} node status --prover-id ${proverId}`);
      
      // –ü–∞—Ä—Å–∏–º –≤—ã–≤–æ–¥ CLI
      const status = this.parseStatusOutput(stdout);
      
      return {
        success: true,
        status: status,
        raw_output: stdout
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        status: 'error'
      };
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  async getNodeMetrics(proverId) {
    try {
      const { stdout } = await execAsync(`${this.cliPath} node metrics --prover-id ${proverId}`);
      
      const metrics = this.parseMetricsOutput(stdout);
      
      return {
        success: true,
        metrics: metrics,
        raw_output: stdout
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        metrics: null
      };
    }
  }

  /**
   * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —É–∑–ª–∞
   */
  async updateNodeConfig(proverId, config) {
    try {
      const configStr = JSON.stringify(config);
      const { stdout } = await execAsync(`${this.cliPath} node config --prover-id ${proverId} --config '${configStr}'`);
      
      return {
        success: true,
        message: 'Configuration updated successfully',
        output: stdout
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–≥–æ–≤ —É–∑–ª–∞
   */
  async getNodeLogs(proverId, lines = 100) {
    try {
      const { stdout } = await execAsync(`${this.cliPath} node logs --prover-id ${proverId} --lines ${lines}`);
      
      return {
        success: true,
        logs: stdout.split('\n').filter(line => line.trim())
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        logs: []
      };
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤
   */
  getRunningNodes() {
    const nodes = [];
    for (const [proverId, process] of this.runningNodes) {
      nodes.push({
        prover_id: proverId,
        pid: process.pid,
        status: process.killed ? 'stopped' : 'running'
      });
    }
    return nodes;
  }

  /**
   * –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –∑–∞–ø—É—Å–∫–∞
   */
  buildStartCommand(proverId, options = {}) {
    let command = `${this.cliPath} node start --prover-id ${proverId}`;
    
    if (options.config) {
      command += ` --config '${JSON.stringify(options.config)}'`;
    }
    
    if (options.logLevel) {
      command += ` --log-level ${options.logLevel}`;
    }
    
    if (options.workers) {
      command += ` --workers ${options.workers}`;
    }
    
    return command;
  }

  /**
   * –ü–∞—Ä—Å–∏–Ω–≥ –≤—ã–≤–æ–¥–∞ —Å—Ç–∞—Ç—É—Å–∞
   */
  parseStatusOutput(output) {
    const lines = output.split('\n');
    const status = {};
    
    for (const line of lines) {
      if (line.includes('Status:')) {
        status.status = line.split(':')[1].trim().toLowerCase();
      } else if (line.includes('Uptime:')) {
        status.uptime = line.split(':')[1].trim();
      } else if (line.includes('Tasks:')) {
        status.tasks_completed = parseInt(line.split(':')[1].trim()) || 0;
      } else if (line.includes('Points:')) {
        status.nex_points = parseInt(line.split(':')[1].trim()) || 0;
      }
    }
    
    return status;
  }

  /**
   * –ü–∞—Ä—Å–∏–Ω–≥ –≤—ã–≤–æ–¥–∞ –º–µ—Ç—Ä–∏–∫
   */
  parseMetricsOutput(output) {
    const lines = output.split('\n');
    const metrics = {};
    
    for (const line of lines) {
      if (line.includes('CPU:')) {
        metrics.cpu_usage = parseFloat(line.split(':')[1].replace('%', '').trim()) || 0;
      } else if (line.includes('Memory:')) {
        metrics.memory_usage = parseFloat(line.split(':')[1].replace('%', '').trim()) || 0;
      } else if (line.includes('Network:')) {
        metrics.network_usage = line.split(':')[1].trim();
      } else if (line.includes('Block Height:')) {
        metrics.block_height = parseInt(line.split(':')[1].trim()) || 0;
      }
    }
    
    return metrics;
  }

  /**
   * –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
   */
  cleanup() {
    for (const [proverId, process] of this.runningNodes) {
      try {
        process.kill('SIGTERM');
        console.log(`üõë Stopped node ${proverId}`);
      } catch (error) {
        console.error(`‚ùå Failed to stop node ${proverId}:`, error);
      }
    }
    this.runningNodes.clear();
  }
}

module.exports = NexusCLI; 